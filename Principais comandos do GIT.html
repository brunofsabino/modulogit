Principais comandos do GIT


BRANCH - SÃO VERSÕES DIFERENTE DO SISTEMA
A VERSÃO PRINCIPAL DO SISTEMA CHAMA-SE ***MASTER***

TER VARIOS BRANCH SERVE PARA DUAS OU MAIS PESSOAS (OU EQUIPES) TRABALHAREM NO MESMO PROJETO.

COMMIT - É QUANDO FAZ ALTERAÇÕES NO SISTEMA (EDITA, DELETA, UPOLAD) E PASSA ESSA ATUALIZAÇÃO PARA O GIT - O COMMIT SALVA AS ALTERAÇÕES FEITA NO SISTEMA 
	*****O COMMIT VC ENVIAR PARA O GIT AS MODIFICAÇÕES QUE VC FEZ NO SISTEMA****



git add	README.md = PARA ADICIONAR NOVOS ARQUIVOS AO CONTROLE DO GIT

git add -A = ADICIONA TODOS OS ARQUIVOS QUE NÃO ESTÃO TRAQUEADOS PELO GIT

git commit -m "Nome do Commit" = COMITANDO OS NOVOS ARQUIVOS PARA O GERENCIAMENTO DO GIT 

git status = INFORMA A SITUAÇÂO DOS ARQUIVOS DO BRANCH E SE É NECESSARIO DAR COMMIT PARA QUE OS ARQUIVOS SEJAM SALVOS NO GIT

git log = VISUALIZA A LISTA DE TODAS AS COMMITS QUE FORAM FEITA NO BRANCH 


git commit -am "comitando" = COMITA OS ARQUIVOS DE FORMA DIRETA, SEM PRECISAR USAR O COMANDO PARA TRAQUEAR OS ARQUIVOS (git add -A)





*************** QUANDO UMA ATUALIZAÇÃO EM UM ARQUIVO É FEITA, OU QUANDO NOVOS ARQUIVOS SÃO CRIADOS, É NECESSARIO DAR UM git status PRIMEIRO PARA O GIT INFORMAR AS ALTERAÇÕES QUE FORAM FEITAS NOS ARQUIVOS ****************

	DEPOIS PARA ADICIONAR AS ALTERAÇÕES E OS NOVOS ARQUIVOS, É NECESSÁRIO UTILIZAR O COMANDO git add -A 

		LOGO APÓS É NECESSÁRIO DAR O COMANDO git status PARA VERIFICAR A SITUAÇÃO DOS ARQUIVOS DO BRANCH

			PORÉM, É NECESSÁRIO DAR COMMIT PARA QUE OS NOVOS ARQUIVOS E ATUALIZAÇÕES SEJAM SALVAS NO GIT, CASO CONTRARIO, AS ALTERAÇOES FICARAM
			SALVAS SOMENTE NO PC

				git commi -m "nome da atualização"

		****PARA COMITAR UMA ATUALIZAÇÃO DE UMA VEZ, É NECESSARIO USAR O COMANDO git commit -am "titulo do Commit"***


git branch = MOSTRA TODOS OS BRANCH DO SISTEMA 




*********REVERTENDO MODIFICAÇÔES********				

	PARA REVERTER MODIFICAÇÕES, É NECESSÁRIO DAR O COMANDO git log E VAI APARECER TODAS AS ALTERAÇÕES FEITAS E NO SISTEMA.
		LOGO APÓS É NECESSÁRIO COPIAR O NUMERO DO COMMIT QUE DESEJA VOLTAR (EXEMPLO: 8342b72d57c388c244fe45e3960c6d30931ae952) E USAR O COMANDO git reset


git reset --soft  = O SOFT VAI VOLTAR PARA A ATUALIZAÇÃO ANTERIOR COM OS ARQUIVOS E ALTERAÇÕES PREPARADAS, MAS AINDA NÃO COMMITADAS. VOLTA PARA ANTES DA EXECUÇÃO DO COMMIT

git reset --mixed = O MIXED É PARECIDO COM O SOFT, A DIFERENÇA É QUE VAI SER NECESSÁRIO DAR O COMANDO git add -A PARA TRAQUEAR OS ARQUIVOS DA ATUALIZAÇÃO

git reset --hard = O HARD APAGA TODOS OS ARQUIVOS POSTERIORES A ATUALIZAÇÃO E VOLTA TODOS OS ARQUIVOS PARA A COMMIT ESCOLHIDA DE RETORNO

	 EXEMPLO DE RETORNO DE MODIFICAÇÕES:
	 	git reset --hard 67331f040f25a96c8c1d8de276d2848d9d9b9bc1

	 	git reset --soft 67331f040f25a96c8c1d8de276d2848d9d9b9bc1

	 	git reset --mixed 67331f040f25a96c8c1d8de276d2848d9d9b9bc1



********* CRIANDO BRANCH ****************

PARA CRIAR UM NOVO BRANCH É NECESSÁRIO DAR O COMANDO git branch NovoBranch, ASSIM É CRIADO UM BRANCH COM O NOME DE NovoBranch 


git branch = MOSTRA TODOS OS BRANCH DO SISTEMA 



********** TROCANDO DE BRANCH ***************

git checkout NovoBranch = ASSIM VAI SER O BRANCH ATUAL PASSA A SER O BRANCH NovoBranch
	
	*******	E TODAS AS ALTERAÇÕES FEITAS NO SISTEMA E NOS ARQUIVOS A PARTIR DAI, VÃO SER SALVAS SOMENTE NO BRANCH NovoBranch *******

	QUANDO SE CRIA UM NOVO BRANCH, O GIT IMPORTA TUDO O QUE TINHA NO BRANCH ATUAL E COMEÇA UM HISTORICO A PARTI DAI *****

	QUANDO SE DA O COMANDO git checkout master, O GIT VOLTA PARA O BRANCH PRINCIPAL E NECESSÁRIO FAZER UM git status  E VAI APARECER AS ATUALIZAÇÕES NÂO RECONHECIDAS PELO BRANCH MASTER, POIS O QUE FOI ATUALIZADO NO BRANCH NovoBranch NÂO APARECE NO BRANCH master




************** MOSTRAR AS ATUALIZAÇÕES FEITAS NOS ARQUIVOS ***************

					*******************************
git diff = MOSTRA DETALHADO AS ALTERAÇÕES FEITAS NOS ARQUIVOS, ANTES DE COMITAR
					*******************************

git diff --name-only = MOSTRA O NOME DOS ARQUIVOS QUE FORAM MODIFICADOS, PARA ASSIM, LOGO APOS ELES SEREM COMITADOS.


git diff style.css = ESTE COMANDO MOSTRA NO ARQUIVO (NESTE EXEMPLO, FOI USADO O style.css), QUAIS ALTERAÇÔES FORAM FEITAS

***********************************************

**************VOLTANDO HA UMA CONFIGURAÇÂO ANTERIOR DO ARQUIVO **********************
git checkout HEAD -- style.css = ESTE COMANDO VOLTA NA VERSÂO ANTERIOR DO ARQUIVO, NESTE EXEMPLO, AS LINHAS QUE ESTAVAM NO style.css FORAM EXCLUIDAS, POIS ESTE COMANDO FEZ COM QUE O ARQUIVO VOLTASSE PARA AS ATUALIZAÇÔES ANTERIORES




 
******************** Conectando repositório local ao remoto******************
					SUBINDO O ARQUIVO LOCAL PARA O GIT 
https://help.github.com/articles/connecting-to-github-with-ssh/
https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/



 https://github.com/brunofsabino/modulogit.git (push)
 git remote add origem https://github.com/brunofsabino/modulogit.git
 git push -u origem master



******************Fazendo alterações no repositório remoto*************
DEPOIS DE QUALQUER ALTERAÇÂO NOS ARQUIVOS.. é NECESSARIO DAR COMMIT git commit -am "nome" - e DEPOIS TEM QUE DAR PUSH PARA AS ATUALIZAÇÔES IR PARA O REPOSITORIO REMOTO  git push origin master

*******************************************************